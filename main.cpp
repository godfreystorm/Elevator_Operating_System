/*
 *
 *  final project - Ikponmwosa Godfrey Osagiede
 *
 *  purpose: interact with an elevator OS through GET and PUT network commands, efficently schedule elevator passengers to reduce overall wait and ride time.
 *
 */

#include <iostream>
#include <curl/curl.h>
#include <thread>
#include <mutex>
#include <chrono>
#include <sstream>
#include <vector>
#include <fstream>
#include <map>
#include <set>
#include <algorithm>
#undef max
#undef min

// generated by --libcurl
void start_simulation( ) {
	CURLcode ret;
	CURL* hnd;

	hnd = curl_easy_init( );
	curl_easy_setopt( hnd, CURLOPT_BUFFERSIZE, 102400L );
	curl_easy_setopt( hnd, CURLOPT_URL, "http://localhost:5432/Simulation/start" );
	curl_easy_setopt( hnd, CURLOPT_NOPROGRESS, 1L );
	curl_easy_setopt( hnd, CURLOPT_USERAGENT, "curl/8.4.0" );
	curl_easy_setopt( hnd, CURLOPT_MAXREDIRS, 50L );
	curl_easy_setopt( hnd, CURLOPT_CUSTOMREQUEST, "PUT" );
	curl_easy_setopt( hnd, CURLOPT_FTP_SKIP_PASV_IP, 1L );
	curl_easy_setopt( hnd, CURLOPT_TCP_KEEPALIVE, 1L );
	ret = curl_easy_perform( hnd );

	while ( ret != CURLE_OK ) {
		std::this_thread::sleep_for( std::chrono::milliseconds( 1 ) );
		std::cout << "failed to start simulation, retrying..." << std::endl;
		ret = curl_easy_perform( hnd );
	}

	curl_easy_cleanup( hnd );
	hnd = NULL;
}

struct person_t {
	std::string name;
	int start;
	int end;
	int direction; // 1 for up, -1 for down
};

static size_t write_callback( void* contents, size_t size, size_t nmemb, void* userp ) {
	( ( std::string* )userp )->append( ( char* )contents, size * nmemb );
	return size * nmemb;
}

person_t parse_person( const std::string& input ) {
	std::istringstream stream( input );
	std::string name;
	int start, finish;
	std::string in{ };

	std::getline( stream, name, '|' );

	std::getline( stream, in, '|' );

	start = std::stoi( in );

	std::getline( stream, in );

	finish = std::stoi( in );

	int direction = ( finish > start ) ? 1 : -1;

	return { name, start, finish, direction };
}

person_t get_next_input( ) {
	CURLcode ret;
	CURL* hnd;
	std::string buffer;

	hnd = curl_easy_init( );
	curl_easy_setopt( hnd, CURLOPT_BUFFERSIZE, 102400L );
	curl_easy_setopt( hnd, CURLOPT_URL, "http://localhost:5432/NextInput" );
	curl_easy_setopt( hnd, CURLOPT_NOPROGRESS, 1L );
	curl_easy_setopt( hnd, CURLOPT_USERAGENT, "curl/8.4.0" );
	curl_easy_setopt( hnd, CURLOPT_MAXREDIRS, 50L );
	curl_easy_setopt( hnd, CURLOPT_CUSTOMREQUEST, "GET" );
	curl_easy_setopt( hnd, CURLOPT_FTP_SKIP_PASV_IP, 1L );
	curl_easy_setopt( hnd, CURLOPT_TCP_KEEPALIVE, 1L );
	curl_easy_setopt( hnd, CURLOPT_WRITEFUNCTION, write_callback );
	curl_easy_setopt( hnd, CURLOPT_WRITEDATA, &buffer );

	ret = curl_easy_perform( hnd );

	if ( ret != CURLE_OK ) {
		std::cout << "fatal error or completed" << std::endl;
		exit( 0 );
	}

	curl_easy_cleanup( hnd );
	hnd = NULL;

	if ( buffer.find( "NONE" ) != std::string::npos )
		return { "", -1, -1 };

	return parse_person( buffer );
}

void add_person_to_elevator( const std::string& name, const std::string& elevator ) {
	CURLcode ret;
	CURL* hnd;

	std::string url = "http://localhost:5432/AddPersonToElevator/" + name + "/" + elevator;

	hnd = curl_easy_init( );
	curl_easy_setopt( hnd, CURLOPT_BUFFERSIZE, 102400L );
	curl_easy_setopt( hnd, CURLOPT_URL, url.c_str() );
	curl_easy_setopt( hnd, CURLOPT_NOPROGRESS, 1L );
	curl_easy_setopt( hnd, CURLOPT_USERAGENT, "curl/8.4.0" );
	curl_easy_setopt( hnd, CURLOPT_MAXREDIRS, 50L );
	curl_easy_setopt( hnd, CURLOPT_CUSTOMREQUEST, "PUT" );
	curl_easy_setopt( hnd, CURLOPT_FTP_SKIP_PASV_IP, 1L );
	curl_easy_setopt( hnd, CURLOPT_TCP_KEEPALIVE, 1L );
	ret = curl_easy_perform( hnd );

	std::cout << std::endl;

	if ( ret != CURLE_OK ) {
		std::cout << "fatal error or completed" << std::endl;
		exit( 0 );
	}

	curl_easy_cleanup( hnd );
	hnd = NULL;
}

struct elevator_t {
	std::string name;
	int lowest_floor;
	int highest_floor;
	int cur_floor;
	int max_capacity;
	bool running;
	int cur_capacity;
	int direction;
	int queued_capacity;
	int queued_direction;
};

void parse_elevator( elevator_t* elevator, const std::string& input ) {
	try {
		std::istringstream stream( input );
		std::string in{ };
		std::getline( stream, in, '|' );
		std::getline( stream, in, '|' );
		elevator->cur_floor = std::stoi( in );
		std::getline( stream, in, '|' );
		switch ( in[ 0 ] ) {
		case 'S':
			elevator->running = false;
			break;
		case 'U':
			elevator->direction = 1;
			elevator->running = true;
			break;
		case 'D':
			elevator->direction = -1;
			elevator->running = true;
			break;
		case 'E':
			elevator->running = true;
			elevator->direction = 0;
		}
		std::getline( stream, in, '|' );
		std::getline( stream, in );
		// set our current capacity to our queued + remaining.
		elevator->cur_capacity = elevator->max_capacity - std::stoi( in ) + elevator->queued_capacity;
	}
	catch ( ... ) {
	}
}

void get_elevator_status( elevator_t* elevator ) {
	CURLcode ret;
	CURL* hnd;

	std::string url = "http://localhost:5432/ElevatorStatus/" + elevator->name;

	std::string buffer;

	hnd = curl_easy_init( );
	curl_easy_setopt( hnd, CURLOPT_BUFFERSIZE, 102400L );
	curl_easy_setopt( hnd, CURLOPT_URL, url.c_str( ) );
	curl_easy_setopt( hnd, CURLOPT_NOPROGRESS, 1L );
	curl_easy_setopt( hnd, CURLOPT_USERAGENT, "curl/8.4.0" );
	curl_easy_setopt( hnd, CURLOPT_MAXREDIRS, 50L );
	curl_easy_setopt( hnd, CURLOPT_CUSTOMREQUEST, "GET" );
	curl_easy_setopt( hnd, CURLOPT_FTP_SKIP_PASV_IP, 1L );
	curl_easy_setopt( hnd, CURLOPT_TCP_KEEPALIVE, 1L );
	curl_easy_setopt( hnd, CURLOPT_WRITEFUNCTION, write_callback );
	curl_easy_setopt( hnd, CURLOPT_WRITEDATA, &buffer );
	ret = curl_easy_perform( hnd );

	if ( ret != CURLE_OK ) {
		std::cout << "fatal error or completed" << std::endl;
		exit( 0 );
	}

	curl_easy_cleanup( hnd );
	hnd = NULL;

	parse_elevator( elevator, buffer );
}

struct group_t {
	std::vector<person_t> people;
	elevator_t* elevator;
};

std::vector<elevator_t*> elevators{};
std::mutex elevator_lock{};

std::vector<person_t> queue{};
std::mutex queue_lock{};

std::vector<group_t> groups{};
std::mutex group_lock{};

bool input_ready = false;

void input_thread( ) {
	while ( true ) {
		const auto person = get_next_input( );
		if ( person.start == -1 ) {
			std::this_thread::sleep_for( std::chrono::milliseconds( 100 ) ); // yield thread to prevent excessive api calls.
			continue;
		}

		queue_lock.lock( );
		queue.push_back( person );
		input_ready = true;
		queue_lock.unlock( );
	}
}

bool data_ready = false;

void output_thread( ) {
	while ( true ) {
		group_lock.lock( );
		if ( !data_ready ) {
			group_lock.unlock( );
			std::this_thread::sleep_for( std::chrono::milliseconds( 25 ) );
			continue;
		}

		data_ready = false;

		auto _groups = groups;
		

		for ( auto& group : _groups ) {
			auto& elevator = group.elevator;

			for ( auto& person : group.people ) {
				add_person_to_elevator( person.name, elevator->name );
				// remove our queued additions as now the passengers are being assigned.
				elevator->queued_capacity--;
				elevator->queued_direction = 0;
			}
		}

		group_lock.unlock( );
		std::this_thread::sleep_for( std::chrono::milliseconds( 25 ) );
	}
}

void update_elevators( ) {
	while ( true ) {
		// update stats about the elevators.
		for ( auto& elevator : elevators ) {
			get_elevator_status( elevator );
		}
		std::this_thread::sleep_for( std::chrono::milliseconds( 200 ) );
	}
}

bool is_suitable( const elevator_t* elevator, const person_t& person ) {
	// check if the elevator is queued to go in the same direction, OR is already heading in the same direction as the passenger
	bool same_direction = elevator->queued_direction == person.direction && elevator->queued_direction != 0 || elevator->direction == person.direction && elevator->queued_direction == 0;
	// ensure the elevator matches the requirements of the person, and check if it will go over capacity.
	return person.start >= elevator->lowest_floor && person.end <= elevator->highest_floor &&
		person.start <= elevator->highest_floor && elevator->cur_capacity + 1 <= elevator->max_capacity && (!elevator->running || same_direction);
}

int next_elevator_index = 0;

// find the closest elevator to the person based on current floor.
int find_closest( const std::vector<elevator_t*>& elevators, const person_t& person ) {
	int min_distance = std::numeric_limits<int>::max( );
	int best_index = -1;
	for ( int i = 0; i < elevators.size( ); ++i ) {
		auto& elevator = elevators[ i ];
		if ( elevator->cur_capacity < elevator->max_capacity && is_suitable( elevator, person ) ) {
			int distance = std::abs( elevator->cur_floor - person.start );
			if ( distance < min_distance ) {
				min_distance = distance;
				best_index = i;
			}
		}
	}
	return best_index;
}

std::vector<group_t> get_groups( const std::vector<person_t>& people, std::vector<elevator_t*>& elevators ) {
	std::vector<group_t> groups;
	std::vector<person_t> sorted_people = people;

	// sort by starting location to more efficiently path riders.
	std::sort( sorted_people.begin( ), sorted_people.end( ), [ ]( const person_t& a, const person_t& b ) {
		return a.start < b.start;
		} );

	for ( auto& person : sorted_people ) {
		bool placed = false;
		start: // infinite loop until a rider is placed in a group
		int index = find_closest( elevators, person );
		if ( index == -1 ) {
			do {
				index = next_elevator_index;
				next_elevator_index = ( next_elevator_index + 1 ) % elevators.size( );
			} while ( !is_suitable( elevators[ index ], person ) );
		}

		if ( elevators[ index ]->cur_capacity + 1 < elevators[ index ]->max_capacity ) {
			elevators[ index ]->queued_capacity++;

			// find a group thats assigned to the same elevator.
			auto it = std::find_if( groups.begin( ), groups.end( ), [ & ]( const group_t& group ) {
				return group.elevator == elevators[ index ];
				} );

			if ( it != groups.end( ) ) {
				it->people.push_back( person );
				placed = true;
			}
			else { // create a new group if we don't already have one.
				group_t new_group;
				new_group.elevator = elevators[ index ];
				new_group.elevator->queued_direction = person.direction;
				new_group.people.push_back( person );
				groups.push_back( new_group );
				placed = true;
			}
		}

		if ( !placed )
			goto start; // if we didnt get assigned to a group continue.
	}

	return groups;
}


void scheduler( ) {
	while ( true ) {
		queue_lock.lock( );
		if ( !input_ready ) {
			queue_lock.unlock( );
			std::this_thread::sleep_for( std::chrono::milliseconds( 25 ) );
			continue;
		}

		input_ready = false;

		std::vector<person_t> _queue{ };

		_queue = queue;
		queue.clear( );
		

		if ( _queue.empty( ) ) {
			queue_lock.unlock( );
			std::this_thread::sleep_for( std::chrono::milliseconds( 25 ) );
			continue;
		}

		auto _groups = get_groups( _queue, elevators );

		group_lock.lock( );
		groups = _groups;
		data_ready = true;
		group_lock.unlock( );

		queue_lock.unlock( );

		std::this_thread::sleep_for( std::chrono::milliseconds( 25 ) );
	}
}

int main( int argc, char** argv ) {

	std::cout << "Ikponmwosa Godfrey Osagiede" << std::endl;
	std::cout << "R11642267" << std::endl;

	if ( argc <= 1 ) {
		printf( "ERROR: building not specified\n" );
		return 2;
	}

	std::string file_name = std::string( argv[ 1 ] );
	std::string line;
	std::ifstream file( file_name );

	while ( std::getline( file, line ) ) {
		elevator_t* elevator = new elevator_t( );;
		std::istringstream ss( line );
		ss >> elevator->name >> elevator->lowest_floor >> elevator->highest_floor >> elevator->cur_floor >> elevator->max_capacity;
		elevator->running = false;
		elevator->cur_capacity = 0;
		elevator->direction = 0;
		elevators.push_back( elevator );
	}

	start_simulation( );

	std::cout << "\n";

	auto input = std::thread( input_thread );
	auto output = std::thread( output_thread );
	auto schedule = std::thread( scheduler );
	auto update = std::thread( update_elevators );

	input.join( );
	output.join( );
	schedule.join( );
	update.join( );

	return 0;
}